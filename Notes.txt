How it works in Java?
Source code converted to bytecode (sequences of 0's and 1's) by compiler, and then Java virtual machine (JVM) reads the bytecode

Name of Interface must be an adjective: like Runable,Readable,Remote etc

Class name must be noun like Student, Person,Computer,Hashmap etc

Method name must be verb like actionPerfomrmed,run,print,write

For constant, all the letters should be capital like PI,DENSITY etc 

By default 0 is taken as the  value for int etc ratherthan garbage values

Main method is static because in java, to call a mathod we need an object, but we don't have an object at the start of our program so we create a static method and static methods don't require an object to be called

We cannot use a non-static variable in a static block

Java doesn't support multiple inhertitance (due to ambiguity problem) , but C++ supports Multiple InheritanceDemo

Dynamic method dispactch in Java is a fancy name for runtime polymorphism, if I use reference (LHS) of parent class but object of child class (on RHS), it is called runtime polymorphism. A obj=new B(); 

Wrapper classes provide a way to use primitive data types (int, boolean, etc..) as objects.

The table below shows the primitive type and the equivalent wrapper class:

Primitive Data Type	Wrapper Class
byte	Byte
short	Short
int	Integer
long	Long
float	Float
double	Double
boolean	Boolean
char	Character

Java automatically does a conversion of primitive data types into their wrapper classes when assigned. It is called boxing.

public class MyFirstJavaProgram {
   public static void main(String []args) {
      Integer testData = 10; //boxing
      System.out.println(testData);
   }
} (concept of boxing is there in JS also)


Unboxing on the other hand refers to converting an object of a wrapper type to its corresponding primitive value. For example conversion of Integer to int


Autoboxing is the process by which a primitive type is automatically encapsulated (boxed) into its equivalent type wrappers whenever an object of the type is needed. There is no need to construct an object explicitly. Like Integer value=5 will internally create the object using Integer value=new Integer(5) 

Some frameworks in Java work only with wrapper classes and not with primitive data types like int


Abstract class: is a restricted class that cannot be used to create objects (to access it, it must be inherited from another class). Abstract method: can only be used in an abstract class, and it does not have a body. The body is provided by the subclass (inherited from).

In order for a function to be abstract, the corresponding class must also be abstract 

abstract class Human{
    public abstract void eat();
    public void walk(){

    }
}
class Man extends Human{ //this class is known as concrete class
    public void eat(){

    }
}

Example of asbtract Keyword used in Java...class Integer and Float implement the abstract class Number

Final Keyword in Java: Final keyword can be used with methods, classes and variables

Final variable is constant in nature, it's value can't be changed 

There can be use cases where we want to create a final class, a final class cannot be inherited by any other child class

If I declare a method as final,  then this method can't be overriden by any child class. 

===Interface and abstract class===
Interface is same as abstract class, but in abstract class we can have both asbtract methods as well as non-abstract methods, but in case of interface we cannot have non-abstract methods

For interface we use the keyword "implements" and for abstract class, we use the keyword "extends", the benefit of using interface is that in Java we can't have multiple polymorphism so we can't extend from two classes A,B but we can implement an interface and extend a class, something like class B implements A extends Character

Also, in interface we cannot define any method, like public void func(){ ....code .... } will give error, in an interface we can only declare the function, but in case of abstract class we can define the method too like public void speak(){ "Hello this is a general animal speaking" }

Another use case of interfaces in Java: let's say a manager wants to explain what all functionalities he wants in the project, he can give an interface with all the function declarations, so that the other person can come to know what he needs to implement.

Concept of Anonymous inner class: if I want to override a function show() of A, one way is to create a class B extends A and then define the show function inside it, another way is to define an anonymous inner class, something like

obj A=new A(){
    public void show() {...code...}
}

Just like abstract class, we can only create reference of abstract class, we cannot create object of interface.

There are three types of interfaces in Java: 1) Marker interfaces: where the interface has got 0 methods (like serializable interface in Java) (why is such an interface having 0 methods required? ) (will be discussed later)

2) Functional interface or Single Abstract Method interface (SAM interface)-> these are the interfaces having one function (method ) only

 (Very very important) Due to the concept of functional interfaces, we can have lambda expressions in Java

 Yes, in Java, a lambda expression can only be used with a functional interface, which is an interface with exactly one abstract method. The type of the lambda expression is determined by the functional interface it is assigned to. The body of the lambda expression implements the abstract method of the functional interface.

3) Normal interface: interface where there are >=2 methods

Annotations are used to provide supplemental information about a program. 

Annotations start with ‘@’.

From java 1.8 onwards, I have a provision of using non abstract methods in Java (means I can provide the function defintion too), with the help of default method in interfaces using the keyword 'default' 

===A class can extend only one class (>=2 classes are not allowed), but a class Example can implement >=two interfaces, but there's a catch : if there are two conflicting defintions for a function show(), it will complaint, so there could be 2 possible solutions:

1) Redefine the function in the class
2) using super, specify which interface's function should be called

If I create a variable inside an interface, it is by default final in nature, so we can't change the value of a variable inside any class which implements that interface 

What is a java package? A collection of all related files, like for example for I/O, all the relaated classes will be combined in the java.io package. Package name must be such that it must be unique, and no-one else has the same package name. Like if domain name is google.com, then it makes sense to use the package name as com.google

If I want to use all the classes present in com.Telusko, I will use com.Telusko.*

Access modifiers: final,abstract, protected, public and private are called access modifiers in Java (it's different from CPP, in CPP we only have protected, public and private as access modifiers)

Out of these 5, we can't use protected and private with class 

The accessibility of :
private is within the same class
default is within the specified package only (like com.girik only)
public is within any class or package (like package com.nikhil will also be able to access com.girik's class)
Protected members can be accessed within the same package and within subclasses in different packages.

Any illegal operation like 1/0 will throw an object of Exception

There is a third block also,finally, which is executed, rregardless of whether an exception is encountered or not

Checked and unchecked exceptions in Java

"throws" is a keyword in Java used in method declarations to indicate that the method can throw one or more exceptions. It indicates that the method does not handle the exception and that it should be propagated to the caller of the method.

Try-catch block: A try-catch block is used to handle exceptions in a specific block of code. If an exception is thrown within the try block, the catch block is executed, providing an opportunity to handle the exception.

Checked exceptions are exceptions that are checked at compile time, meaning that the code that might throw these exceptions must either handle or declare it.

Unchecked exceptions are exceptions that are not checked at compile time and include runtime exceptions and errors.

Java BufferedReader is a public Java class that reads text, using buffering to enable large reads at a time for efficiency, storing what is not needed immediately in memory for later use. Buffered readers are preferable for more demanding tasks, such as file and streamed readers.

java.io.InputStreamReader is a class in the Java Standard Library (java.io package) that reads characters from an InputStream and decodes them into characters using a specified charset. The InputStreamReader class acts as a bridge between the byte-based input stream and the character-based world of Java.

It provides a way to read data from an InputStream as characters, as opposed to bytes. The InputStreamReader class is often used to read data from a file or network socket.

The InputStreamReader class provides several constructors that allow you to specify the input stream to be read and the charset to be used for decoding. It also provides several methods for reading characters, such as read(), read(char[] cbuf), and readLine().

An exception may be thrown in a BufferedReader in the following scenarios:

FileNotFoundException: This exception is thrown when the specified file is not found. It can occur when the BufferedReader is constructed using the FileReader class, and the file specified in the constructor does not exist.

IOException: This exception is thrown when there is an error while reading from the BufferedReader. This can occur when the readLine() method encounters an end-of-file (EOF) marker or when the underlying input stream throws an IOException.

UnsupportedEncodingException: This exception is thrown when the specified charset is not supported. It can occur when the BufferedReader is constructed using the InputStreamReader class, and the charset specified in the constructor is not supported by the system.

It is important to handle these exceptions properly in your code to ensure that the program continues to run smoothly in the event of an error. This can be done using a try-catch block.

In the syntax:  br = new BufferedReader(new InputStreamReader(System.in));

InputStreamReader is a bridge from byte streams to character streams. It reads bytes from an InputStream and decodes them into characters using a specified charset.

BufferedReader is a buffered character-based input stream. It wraps an existing Reader and buffers the input. This provides an efficient way to read characters, arrays, and lines.

No, you don't always need to write a catch block with a try block. However, it is recommended to use a catch block to handle exceptions thrown by the code in the try block, so that your program can continue to run even if an error occurs. If I am not using a catch block with a try block, then it is compulsory to use finally block

try(BufferedReader br = new BufferedReader(new InputStreamReader(System.in))) what does this syntax mean?

This is an example of a try-with-resources statement in Java. It allows you to declare and automatically close resources that are used in a try block, in this case a BufferedReader. The resource (br) is declared in the parenthesis following the try keyword and is automatically closed at the end of the try block, even if an exception is thrown. This ensures that the resource is properly closed and helps to avoid resource leaks. The try-with-resources statement was introduced in Java 7 to make it easier to manage resources in a more efficient and exception-safe way.

package com.girik;
import java.util.Scanner;
public class UserInput {
    public static void main(String[] args) {
        System.out.println(" Enter a number ");
        Scanner scn = new Scanner(System.in); // system.in is preffered over inputstreamreader anf buffered reader
                                              // because of the easier syntax of Scanner, here system.in specifies that
                                              // we'll be taking input from the input stream (keyboard) instead of a
                                              // file
        int n = scn.nextInt(); // using nextInt has the davnatge that it automatically converts the character
                               // stream to number, and handles the excpetion too
        System.out.println(n);
    }
}

Responsiveness: If the process is divided into multiple threads, if one thread completes its execution, then its output can be immediately returned.
Faster context switch: Context switch time between threads is lower compared to process context switch. Process context switching requires more overhead from the CPU. 

Effective utilization of multiprocessor system: If we have multiple threads in a single process, then we can schedule multiple threads on multiple processor. This will make process execution faster.

Resource sharing: Resources like code, data, and files can be shared among all threads within a process. Note: stack and registers can’t be shared among the threads. Each thread has its own stack and registers.

Communication: Communication between multiple threads is easier, as the threads shares common address space. while in process we have to follow some specific communication technique for communication between two process. 

Enhanced throughput of the system: If a process is divided into multiple threads, and each thread function is considered as one job, then the number of jobs completed per unit of time is increased, thus increasing the throughput of the system. 

The core of a processor refers to a single processing unit within a computer's central processing unit (CPU) that can interpret and execute instructions. It includes all the functional units, such as arithmetic logic unit (ALU) and control unit, needed to process data. A CPU can have multiple cores, allowing for parallel processing and improved performance.


===Multithreading in Java===
By default, the main thread in java excuetes on a single core only. 

Some chat with ChatGPT


Q. what is   a servlet in java
A servlet is a Java class that runs on a Java-enabled web server and acts as a middleware between a web client (typically a browser) and a server-side application.
Servlets handle client requests, process the request data, and generate a dynamic response based on the request. They are commonly used for creating dynamic web pages, handling form submissions, and managing user sessions.
A servlet must implement the javax.servlet.Servlet interface, which defines the methods for initializing, processing requests, and generating responses. The servlet is then deployed to a web server, which takes care of handling incoming requests and forwarding them to the servlet for processing.
In summary, servlets provide a convenient way to build dynamic, interactive web applications in Java. They are widely used and offer a number of benefits, including ease of development, scalability, and compatibility with a variety of web servers and clients.


Q. Give me a practical example to explain how java servlet works
Consider a web application that allows users to search for books by author or title. When a user submits a search request from a web browser, the request is sent to a web server. The web server then forwards the request to a Java servlet that is responsible for processing the request.
Here's how the servlet would process the request:
The servlet receives the request from the web server.
The servlet extracts the search criteria (author or title) from the request data.
The servlet performs a database query to retrieve the matching books.
The servlet generates an HTML page that displays the search results.
The servlet sends the response (the HTML page) back to the web server.
The web server forwards the response to the client's browser, which displays the search results to the user.
In this example, the servlet acts as a bridge between the web client and the server-side application, handling the request and generating a dynamic response based on the user's input. This approach allows for a clean separation between the presentation and the business logic, making it easier to maintain and scale the application.
Q. 

What is MVC
MVC stands for Model-View-Controller, and it is a design pattern used in software engineering to separate an application into three interconnected components:
Model: The model represents the underlying data and the business logic of the application. It manages the application's data and provides an interface for the view and controller to access the data.
View: The view is responsible for displaying the data to the user. It generates the HTML, CSS, and JavaScript code needed to render the user interface.
Controller: The controller acts as the intermediary between the model and the view. It receives user input from the view and updates the model accordingly. It also retrieves data from the model and passes it to the view for rendering.
The MVC design pattern allows for a clear separation of concerns between the different components of the application, making it easier to develop, test, and maintain the code. It also promotes the development of reusable and modular components that can be used in other applications.
In summary, MVC is a design pattern that helps to structure web applications and improve code maintainability and reuse by separating the application into three distinct components: the model, the view, and the controller.

Q. 
Give me a practical example to understand how MVC works
Consider a simple to-do list application. The user can add, edit, and delete tasks, and the application displays a list of all the tasks. Here's how the MVC design pattern could be applied:
Model: The model represents the task data and the business logic for adding, editing, and deleting tasks. It might include a class called Task and another class called TaskList that manages a collection of tasks.
View: The view is responsible for rendering the task list to the user. It might include an HTML template and a JavaScript file that generates the HTML code and updates the user interface.
Controller: The controller acts as the intermediary between the model and the view. It might include a servlet or a controller class that handles HTTP requests from the user, updates the model accordingly, and passes the updated task list to the view for rendering.
Here's how a user interaction might be processed using MVC:
The user submits a request to add a new task.
The controller receives the request and updates the task list in the model by adding the new task.
The controller retrieves the updated task list from the model and passes it to the view.
The view generates the HTML code for the updated task list and sends the response back to the user's browser.
The user's browser displays the updated task list.
In this example, the MVC design pattern allows for a clean separation of concerns between the different components of the application. The model handles the task data and the business logic, the view handles the presentation, and the controller handles the interaction between the model and the view. This makes it easier to develop, test, and maintain the code, as well as to add new features or make changes to the application.


Q. Can I say that java servlet follows MVC pattern
Yes, Java Servlets can follow the Model-View-Controller (MVC) design pattern. The servlet component can be seen as the controller in the MVC architecture, handling user requests and updating the model data, while the model data and business logic are typically implemented as separate Java classes or components. The view component is usually handled by a template engine or a front-end framework such as JSP, JSF, or AngularJS.
In a Java Servlet-based application, the servlet receives user requests, retrieves data from the model, and generates dynamic content based on the data. The generated content is then sent back to the client as a response.
By using the MVC design pattern, developers can achieve a clear separation of concerns between the different components of the application, making it easier to develop, test, and maintain the code. It also allows for greater flexibility and modularity, as different components can be changed or updated without affecting the others.


Q. what is a middleware
Middleware is software that acts as a bridge between two or more software applications or components to facilitate communication and data exchange. Middleware acts as an intermediary between applications, allowing them to communicate and exchange data in a uniform and consistent way, regardless of their underlying platform, programming language, or architecture.
Middleware provides services such as data mapping, data conversion, data validation, data transfer, security, and authentication. By using middleware, developers can reduce the complexity of integrating disparate applications, and ensure that the data exchange between applications is reliable and secure.
There are several types of middleware, including:
Message-oriented middleware: Facilitates communication between applications by passing messages between them.
Remote Procedure Call (RPC) middleware: Allows applications to invoke remote functions or procedures as if they were local.
Object Request Broker (ORB) middleware: Supports object-oriented programming and enables communication between objects running in different environments.
Application server middleware: Supports the development and deployment of web applications and provides services such as security, session management, and database connectivity.
In summary, middleware is a layer of software that provides communication and data exchange services between applications, reducing the complexity of integrating disparate systems and ensuring the reliability and security of data exchange.


Q. what is difference between middle ware and API
API (Application Programming Interface) and middleware are both technologies used for software integration, but they serve different purposes and have different characteristics.
An API is a set of programming interfaces and protocols that allow applications to communicate with each other and exchange data. APIs typically specify the way in which applications can request and receive data or services from each other. For example, a weather API might allow a mobile application to retrieve current weather data from a weather service.
Middleware, on the other hand, is a layer of software that acts as a bridge between applications to facilitate communication and data exchange. Middleware provides services such as data mapping, data conversion, data validation, data transfer, security, and authentication, and enables applications to communicate with each other regardless of their underlying platform, programming language, or architecture.
In summary, APIs provide a way for applications to request and receive data or services from each other, while middleware provides the infrastructure and services needed to facilitate communication and data exchange between applications. While APIs can be seen as the interface between applications, middleware can be seen as the underlying plumbing that enables communication and data exchange to occur.


Q. is controller in mvc and middleware same
No, the controller in the Model-View-Controller (MVC) pattern and middleware are not the same thing, although they can have some similarities.
The controller in the MVC pattern is responsible for handling user requests, updating the model data, and generating the appropriate response. It acts as the central component in the MVC architecture, coordinating the interactions between the model and the view.
Middleware, on the other hand, is a layer of software that acts as a bridge between two or more software applications or components to facilitate communication and data exchange. Middleware provides services such as data mapping, data conversion, data validation, data transfer, security, and authentication.
In some cases, a controller in an MVC-based application could be implemented as middleware, especially in a microservices architecture where each service is responsible for handling a specific aspect of the application. In such cases, the controller would act as middleware by providing a way for the different services to communicate and exchange data with each other.
In summary, the controller in the MVC pattern and middleware are not the same thing, but they can be related and used together in certain software architectures.







What is a Thread? 

Within a program, a thread is a separate execution path. It is a lightweight process that the operating system can schedule and run concurrently with other threads. The operating system creates and manages threads, and they share the same memory and resources as the program that created them. This enables multiple threads to collaborate and work efficiently within a single program.

Why Multithreading? 

A thread is also known as lightweight process. The idea is to achieve parallelism by dividing a process into multiple threads. For example, in a browser, multiple tabs can be different threads. MS Word uses multiple threads: one thread to format the text, another thread to process inputs, etc. More advantages of multithreading are discussed below.

Process vs Thread:

The primary difference is that threads within the same process run in a shared memory space, while processes run in separate memory spaces. Threads are not independent of one another like processes are, and as a result threads share with other threads their code section, data section, and OS resources (like open files and signals). But, like process, a thread has its own program counter (PC), register set, and stack space. 

Multithreading in java can be achieved by either extending the Thread class or by implementing the Runnable interface (the interface is provided because in Java, we can't have multiple inheritance so providing an interface is a good idea)

The join method in the context of Java threads is used to wait for a thread to complete execution. When a join method is called on a thread, the calling thread will block and wait until the thread on which join was called has finished executing. This can be useful for ensuring that a particular thread has completed its work before proceeding with the rest of the program. The join method can be called on any Thread object and is often used with threads created using the Thread class or with threads created using the Executor framework.

In Java, the isAlive method is a method of the Thread class that returns a boolean indicating whether the thread is still executing or not. The method returns true if the thread has been started and has not yet died, and returns false if the thread has completed execution or has not yet been started.

collection,Collection and Collections (collection is a concept, Collection is an interface and Collections is a class)

ArrayList Collection implements List Interface, and the List Interface implements Collection interface

So syntax for creating a Collection is as follows: Collection values=new ArrayList();

By default, a Collection can store any type of value including a string, number or any object. But if I want to restrict that the Collection should only store Integer values (or restrict to any other data type), I need to use Generics from Java.

Syntax for Generic is like: Collection <Integer> values= new ArrayList<> (); (I can even use the syntax Collection <Integer> values= new ArrayList <Integer> )

One difference between Collection and List is that Collection doesn't use indices but List can be referred through indices

Some popular interface and object types in Java are:

1) List and ArrayList
2) Set and Hashset (hashset is like unordered_set of C++, there is no ordering of the way )
3) Set and Treeset (Treeset is like set of C++, it maintains unique sorted order of elements, and uses red black tree internally for its implenentation)
4) Map and HashMap

As a list can be modified using Collections.sort(values);
        Collections.reverse(values); etc, I can say that lists in Java are mutable


====Video 2: Collections framework====

The Collection framework in Java is a set of classes and interfaces that provide a way to store and manage collections of objects. It provides a unified architecture for organizing and manipulating data in Java. The Collection framework includes classes and interfaces for different types of collections, such as lists, sets, and maps, which allow you to store and manage groups of objects. The framework provides methods for adding and removing elements, searching for elements, sorting elements, and more. Using the Collection framework in Java makes it easier to write efficient and readable code, as well as providing a more flexible and scalable way to store and manage collections of objects.

Hierarchy of Java collections:

See these links for details: https://drive.google.com/file/d/17Z9e9vR0Ff_vwZSu515xyKqJeHzrIkj9/view?usp=share_link and https://drive.google.com/file/d/1rJGUL46rUmY-NE59t3Gnfivjzpyl2ZIW/view?usp=share_link

List interface in Java: 1) List is an ordered collection it maintains the insertion order, which means upon displaying the list content it will display the elements in the same order in which they got inserted into the list.

2) We can insert an element at any position in a list

An ArrayList is a dynamic array (re-sizeable array), it grows its size to accomodate new elements and shrinks when elements are removed


By default, capacity of ArrayList is 10, can be seen from ArrayList.class using decompiler

ArrayList internally uses an array to store the elements. Just like arrays, it allows to retrieve the elements by their index.

ArrayList allows duplicate and null values.

ArrayList is an ordered collection. It maintains the insertion order of elements.

We can't create an ArrayList of primtive types like int,char etc. We need to use boxed types like Integer, Character,Boolean etc

Java ArrayList is not synchronized, if multiple threads try to modify an ArrayList at same time, then final outcome will be non-determinstic. We must explicitly synchronize access to an ArrayList if multiple threads are gonna modify it


===Java LinkedList class===

Java LinkedList class can contain duplicate elements
LinkedList class maintains insertion order

The LinkedList class implements Queue and Deque interfaces. Therefore LinkedList can be used as a Queue, Stack or Deque.

LinkedList is not thread-safe. We must explicitly synchronize concurrent modifications to LinkedList in multi-threaded enviornment


===HashSet class overview===

1. Hashset cannot contain duplicate values
2. Hashset can contain null values
3. Hashset is an unordered collection. It doesn't maintain the order in which elements are inserted.
4. Hashset internally uses a HashMap for implementation. 

HashSet is not thread-safe. We must explicitly synchronize concurrent modifications to HashSet in multi-threaded enviornment

===Hashmap Class in Java===

1) Java Hashmap is a hash table based implemntation of Java's map Interface

2 Hahsmap can't have duplicate keys

3) Java HashMap allows null values and null key.

4) HashMap is an unordered collection. It doesn't guarantee amy specific order of elements

5) HashMap is not thread-safe. We must explicitly synchronize concurrent modifications to HashMap in multi-threaded enviornment

The entrySet() method in Java's HashMap class returns a Set view of the mappings contained in this map. The set is backed by the map, so changes to the map are reflected in the set, and vice-versa.

Each element in the returned set is an instance of the Map.Entry interface, which provides access to both the key and value of a mapping in the map. You can use the getKey() and getValue() methods to retrieve the key and value of each entry in the set, respectively.


===JDBC===

JDBC stands for Java Database connectivity

JDBC is a Java API to connect and perform operations (insert,delete,update,select etc.) with the database

JDBC API uses JDBC drivers to connect with the database

Diagrammatic representation of how JDBC works: https://drive.google.com/file/d/1kqJW1KTVnhfpWQqzunIBu1dGnwJb8u0W/view?usp=share_link

In case of Java, the driver that we use is MySQL connector.jar file

To connect Java application with MySQL database, we follow the following steps:

1) Load driver class

2) Create connection using DriverManager

3) Use connection to fire queries (Statement for static queries (static queries like SELECT * FROM TABLE) and PreparedStatement for dynamic queries (dynmaic quaries means parametrised queries like SELECT * FROM TABLE WHERE NAME=?))

4) Process the result

5) Close the connection

The Class.forName method is commonly used in Java to dynamically load a class at runtime. This allows you to load a class that you do not know the name of until runtime, which is useful in situations where the class to be loaded is determined dynamically, such as in plugin systems or reflection-based APIs.

Here is an example that demonstrates the use of Class.forName:

Yes, that's correct! The syntax Class.forName("com.mysql.jdbc.Driver") is used to dynamically load the class com.mysql.jdbc.Driver from the com.mysql.jdbc package.


DAO stands for Data Access Object. It is a design pattern that provides an abstracted interface to some type of database or other persistence mechanism, allowing the application code to interact with the data stored in the database without having to deal with the underlying details of how the data is stored and retrieved.

In Java, a DAO is typically implemented as a separate class that contains methods for performing CRUD (Create, Read, Update, Delete) operations on a database. For example, a DAO class for a user database might have methods to create a new user, retrieve a user by their ID, update a user's information, and delete a user from the database.

The main benefit of using a DAO pattern is that it separates the database access code from the rest of the application, making it easier to maintain and change the code. For example, if you decide to switch from one database technology to another, you can do so without having to change the application code that interacts with the database, as long as the DAO interface remains the same.

Here's an example of a simple DAO class for a User database:


public interface UserDao {
    User findById(int id);
    List<User> findAll();
    void create(User user);
    void update(User user);
    void delete(int id);
}

executeQuery and executeUpdate are two different methods in Java that are used to execute SQL statements in a database.

executeQuery is used to execute SELECT statements and it returns a ResultSet object that contains the result of the query. The ResultSet object can be used to iterate through the rows of the result and retrieve the data.

executeUpdate, on the other hand, is used to execute non-SELECT statements, such as INSERT, UPDATE, DELETE, and others. It returns an integer that represents the number of affected rows in the database.

In general, you should use executeQuery for SELECT statements and executeUpdate for non-SELECT statements. This ensures that you are using the correct method for each type of operation and that you are receiving the expected result.


===Servlets===

See the attached image: https://drive.google.com/file/d/1f7t7UJijqOL3XsjRqoVncEjDCWSguYDT/view?usp=share_link

Whenever there is a request for a dynamic page like abc.html by the client, which the server doesn't have, the server takes the help of web container (like TomCat), the webcontainer uses web.xml file (this file web.xml is called a deployment descriptor) to determine which servlet to call, (servlet is nothing but a Java class at the end of the day), and then the servlet returns the response to the client

fully qualified name means complete path of class like com.girik.addServlet

doPOST() and doGet() methods are used to restrict the type of request that the servlet is handling

PrintWriter out=res.getWriter();
		out.println("Hello"); This is the method we use to write to response in JAVA

        There are two ways to call a servlet inside another servlet: one is request dispatcher and another one is redirect

Like in the current tutorial, I am calling squareServlet inside addServlet, but client doesn't even know that the squareServlet was called, even in the URL /add will be visible

When we want to pass data from one servlet to another servlet or share data between servlets, we use the concept of session management in Java.

lifecycle of a servlet in Java:

1) init() method is called

2) service() method is called, which contains the core logic to handle the request

3) destroy() method is called


The request and response objects are provided by the Tomcat, we don't need to explicitly program the objects.

HTTPServletRequest and HTTPServletResponse are classes in Java.

requestDispatcher and sendRequest: Refer to this link for image: https://drive.google.com/file/d/1D03N8F-phUDXcVXrklTiLiSOWZgw52Vu/view?usp=share_link

In requestDispatcher, I don't know whether the request object was sent by servlet 1 or servlet 2, however let's take the example of Amazon.com, if I click checkout, it redirects me to PayPal servlet, so I want to let the user know thatthey are being served by Paypal servlet.

So, for this purpose, I use sendRequest() servlet, in case of sendRequest, client sends a request object to servlet 1, then the servlet 1 lets the client know that it is being redirected, then the client sends new request object (req2) to the servlet 2 (card details, in case of Paypal), and then response is received from the servlet 2


One way of using sendRequest is through URL rewriting, where we specify the parameters of servlet 2 while calling the first servlet, something like "sq?k="+2, will pass parameter 2 to the  squareServlet servlet

There can be two other ways to use sendRequest(): through HTTP session and cookies.

Firstly, what is the difference between HTTP seesion and cookies?

Session and cookie are both ways to store information on the client side in a web application. However, they have some important differences.

A cookie is a small piece of data that is stored on the client's computer by the web browser. Cookies are used to store information about the client, such as preferences or shopping cart items, so that this information can be accessed later. Cookies are usually stored as key-value pairs and can be accessed by the server on subsequent requests from the client.

A session, on the other hand, is a way to store information on the server side that is associated with a particular client. When a client makes a request to a web application, the server creates a new session if one does not already exist, and it associates a unique session ID with the client. The server can then store information about the client in the session, such as the items in a shopping cart, and access this information on subsequent requests from the client.

The main difference between cookies and sessions is where the information is stored. Cookies are stored on the client's computer, while sessions are stored on the server. This means that sessions are more secure, as the information is stored on the server and is not accessible to the client. However, sessions also have some disadvantages. For example, if the client has multiple tabs or windows open, each tab or window will have its own session, which can cause confusion. Also, sessions consume server resources, as the server needs to store the session information.

In summary, cookies and sessions are both ways to store information on the client side in a web application, but they have different characteristics and are used for different purposes. Cookies are stored on the client's computer and are used to store simple information, such as preferences or shopping cart items. Sessions are stored on the server and are used to store more complex information, such as the items in a shopping cart, but consume server resources and are not accessible to the client.


But, the difference lies in the fact that information shared by ServletConfig is for a specific servlet, while information shared by ServletContext is available for all servlets in the web application.

Another way to specify the routes for the application (without using web.xml file ) is to use Servlet annotation in the servlet, specifying the URL, something like @WebServlet("/about")


===Intro to JSP (Java Server Pages) ====

Firstly, why do I need Java pages when I have servlets? Let's say I want to use HTML inside servlets, the way to do is to specify the HTML tags inside the out.println statement,something like out.println ("<h1> Hello, I am Girik </h1> ") (in Servlets, I use HTML inside a ), but then writing HTML inside Java is a bit cumbserome process, so Java Server Pages allows us to write Java inside pages, something like add.jsp file, 

<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body bgcolor="cyan">
	<% 
			int i=Integer.parseInt(request.getParameter("num1"));
			int j=Integer.parseInt(request.getParameter("num2"));
			int k=i+j;
			
			out.println("Output: "+k);
		%>
</body>
</html>

There's something known as implicit objects in JSP, for example in this code, I didn't explicitly declare request or out, they are implicit objects in JSP.

Question arises: Why do I need Servlets when JSP is much easier to program?

Reason is that I can program in Servlet, but Apache Tomcat is a servlet container, so that means Tomcat can serve servlets only

How JSP is converted into servlet?

1) if the JSP file is saved as demo.jsp file, then a servlet is created with the name of the class as DemoJSP

2) there are four types of scripting elements in JSP: see the attached image for visual explanation: https://drive.google.com/file/d/1yXS5UigFJxVh8RcfyS-dSW9a6OWVqn88/view?usp=share_link


2.1 First type of scripting element is scriptlet, which is defined by <% %>, sign,whatever we specify inside the scriptlet goes inside the service function of servlet

2.2 Second type of scripting element is declaration, the use case of this scripting element is when we want to declare a variable or a function outside the service function of servlet, I can do that with the help of the declaration, syntax of declaration is <%!  %>

2.3 Third type of scripting element is declarative, the use case of this scripting element is, if I want to import any classes into the servlet, I can specify them by using the directive tag, something like <@ page import="java.util.Date" %>

2.4 Fourth one is expression, suppose I want to print anything to the UI,  instead of using out.println("Hello"), I can use JSP expression, the syntax is <%= "some text" %>


There are 3 types of directives in JSP:

1)  page directive
2) include directive
3) taglib directive

The page directive defines attributes that apply to an entire JSP page.

The include directive is used to include the contents of any resource it may be jsp file, html file or text file. The include directive includes the original content of the included resource at page translation time (the jsp page is translated only once so it will be better to include static resource).

Usecase of include directive: every page in the web app will use a header file, so instead of writing the code for header component repeatedly, we can include the header.jsp file

The taglib directive is used to declare a tag library in a JSP (JavaServer Pages) page. It allows you to use custom tags from the specified library in your JSP pages.

The taglib directive has the following syntax:


<%@ taglib uri="uri" prefix="prefix" %>
uri: This is the Uniform Resource Identifier (URI) of the tag library. It specifies the location of the tag library, which can be either an absolute URL or a relative URL.
prefix: This is a short string that you can use to refer to the tag library in your JSP pages. The prefix is followed by a colon (:) and the name of the custom tag.

Here is an example of a taglib directive:


<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %>

Implicit objects in JSP:

1. request (HTTPServletRequest)
2. response (HTTPServletResponse)
3. pageContext (PageContext)
4. out (JSPWriter) ~ PrintWriter object
5. session (HttpSession)
6. application (ServletContext)
7. config (ServletConfig)

The pageContext object can be used to set,get or remove attribute from one of the following scopes:
page
request
session
application


In JavaServer Pages (JSP) technology, the term "scope" refers to the visibility and lifetime of an attribute within the context of a web application. There are four different scopes available in JSP:

page scope: An attribute with page scope is only visible to the JSP page in which it was declared. It is only accessible while the JSP page is being processed, and it is automatically destroyed when the JSP page is finished processing.

request scope: An attribute with request scope is visible to all JSP pages and servlets that are called in response to the same client request. Once the response has been sent back to the client, the attribute is automatically destroyed.

session scope: An attribute with session scope is associated with a user session, and it is visible to all JSP pages and servlets that are accessed by the same user during the lifetime of the session. The attribute is automatically destroyed when the user's session ends.

application scope: An attribute with application scope is visible to all JSP pages and servlets in the same web application. It is stored in the ServletContext object and is accessible throughout the lifetime of the web application.


Here are some use cases for request scope:

Storing form data that was submitted by the user. For example, you can use request scope to store data that was entered in an HTML form, and then use that data to generate a dynamic response.
Sharing data between multiple JSP pages that are part of the same request. For example, you can use request scope to store data that is used by multiple JSP pages, such as the results of a database query.


Here are some use cases for application scope:

Storing data that is shared by multiple users and multiple requests. For example, you can use application scope to store data that is used by multiple JSP pages, such as a configuration settings or the results of a database query that doesn't change frequently.
Storing data that is global to the web application. For example, you can use application scope to store data such as the number of users that are currently accessing the web application.



In order to use the excption object, the isErrorpage attribute of page directive must be true

Class.forName("com.mysql.jdbc.Driver");

The Class.forName method in Java is used to dynamically load a class at runtime, whereas importing a class in a Java file is a way to bring the class into the scope of the file so that it can be used without specifying the fully-qualified class name.

There are several reasons why you might use Class.forName instead of an import statement:

Late Binding: With Class.forName, you can bind to a class at runtime, which means you can determine the class to be used at runtime based on user input or other dynamic conditions.

Loading Classes from Different Class Loaders: When you use Class.forName, you can specify a class loader, which allows you to load classes from different sources, such as different JAR files.

Hidden Dependencies: When you use Class.forName, you don't need to explicitly import the class or its dependencies in the source code, which can be useful in cases where you want to hide the dependencies from the client code.

In general, if you know the class you want to use at compile time, it's usually easier to simply import it. But if you need to dynamically load classes at runtime, or if you have other specific requirements, Class.forName can be a useful tool.



MVC architecture in Java explained:

Let's take the example of a page which shows the marks of a Student

1. The view has the layout of the page to be displayed, it doesn't have the actual marks of any student, the view in Java is provided by JSP (so we should avoid writng any business logic inside JSP), the view can be static (which can be implemneted with the help of HTML) or dynamic view (like that provided by JSP), dynamic view here means that the data to be displayed is not hardcoded

2. The model has the actual data of the students's marks 

3. The contoller in Java is provided by Servlets, explained below.

How the flow happens?

1. Client makes a request for /getMarks
2. The controller first takes charge, and fetches the data from the model.
3. The controller passes the data (from the model) to the view
4. The view renders the page, and this view is passed to the client

In JSP, I can use expression language, which helps me to eliminate java code To overcome the above problem, we have to use Expression Language syntax along with standard actions, custom actions, and JSTL tag library.

Syntax: ${expression}, expression is the value present which is evaluated at runtime and being sent to the output stream.

<!-- c:import url="https://en.wikipedia.org/wiki/Java_(programming_language)"> </c:import> --> will load the wikipedia page using JSTL tag.

	<c:forEach items="${students}" var="s">
	${s.name} <br/>
	</c:forEach> (Pasting here because not able to comment in JSP, so this information will be permanently lost otherwise)

Here is an example of how to use the <c:forEach> tag to loop over an array of strings and output each string:

kotlin
Copy code
<c:forEach var="item" items="${myArray}">
  <c:out value="${item}"/><br>
</c:forEach>
In this example, myArray is the name of the array that we want to loop over. The <c:forEach> tag creates a loop that iterates over each element in the array. The var attribute specifies the name of the loop variable (in this case, item), and the items attribute specifies the array that we want to loop over.


My doubt was: 

How does Expression language resolve the scope of the variable which I am using? Like if I use the syntax {name}, how does Expression language come to know whether name is to be used from same JSP file or from the request object

Answered by ChatGPT:

In Expression Language (EL), the scope of the variable is determined by a set of predefined rules. If a variable is used without any scope resolution, it is first checked in the page scope, then in the request, session, and finally in the application scope.

For example, if you use the expression ${name} in your JSP file, EL will look for a variable named "name" in the page scope, then in the request, session, and finally in the application scope. If the variable is found in any of the scopes, the value of the variable is used. If the variable is not found, EL returns a null value.

If you want to explicitly specify the scope of the variable, you can use the following syntax:

${pageScope.name} - looks for the variable in the page scope
${requestScope.name} - looks for the variable in the request scope
${sessionScope.name} - looks for the variable in the session scope
${applicationScope.name} - looks for the variable in the application scope
Using this syntax, you can explicitly specify which scope to search for the variable in.


Using functions in JSTL tag libraries: 

Syntax: ${fn:toUpperCase('hello world')}
This will output HELLO WORLD.

Note that the fn prefix in the example above refers to the JSTL function tag library, which provides a set of commonly used functions that you can use in Expression Language. If you want to use functions from other libraries or custom functions, you need to specify the appropriate prefix for those libraries.


===Servlet Filter===

Concept of Filters in Java:

Let's say I have three servlets A,B,C

Servlets A and B have a common concern of logging
Servlets B and C have a common concern of transaction management

Servlets A,B and C all have a common concern of implementing security

So instead of writing their code inidividually, I can create a filter between the client and the servlet, if the request passes the filter, it will go to the servlet, else the filter can return an error response (or any other response) to the client.

It may be possible that multiple filters may be needed to be used, so in this case if for example, I use two filters before servlet A, then it is known as filter chaining.

Where do we configure which filter do we use for servlet, means how do we specify that I need to call the X filter while using servlet A? I can specify it using the web.xml file


To create a filter for a Java servlet, you need to create a class that implements the javax.servlet.Filter interface. 

There are three methods in the filter class viz  init(), doFilter(req,res,chain) and destroy() method 

The init method is called by the servlet container when the filter is first loaded. It is typically used to initialize any resources or data structures that the filter needs to perform its filtering duties. For example, if your filter needs to read configuration settings from a file, you would typically do that in the init method.

The destroy method is called by the servlet container when the filter is about to be unloaded. It is typically used to release any resources or data structures that the filter allocated during its lifetime. For example, if your filter opened a database connection in the init method, you would typically close that connection in the destroy method.


See this image for better clarity on this topic: https://drive.google.com/file/d/1mhqxE5tNRa3IWlLIiWqT4LGa19y34GNU/view?usp=share_link


Formally, I can define filters as : (defintion provided by ChatGPT)
In a Java servlet-based web application, a filter is a component that is executed before the request reaches the servlet or after the response is generated by the servlet. Filters are used to perform pre-processing and post-processing of requests and responses, such as authentication, authorization, logging, encryption, and compression.



Implmenting login using JSP and servlets: HTTP is a stateless protocol, so if I login on one page, I shouldn't be required to login on another page

Website is nothing but a collection of webpages.

Let's say I want two pages, welcome.jsp and videos.jsp which should be accessible only if the user is logged in, else that person should not be able to access these pages if they are not logged in, so I want to make sure that if someone tries to access website.com/videos.jsp by entering the URL, they shouldn't be able to access it.

For this, I can have two solutions: one is to use sessions and the other is to use cookies, There's generally a debate on which one is better, the difference between the two is that cookies are stored on the client side, but the session is managed on the server side.

So, in the code of login.jsp, I can use sesssion.setAttribute("uname",girik) to set the username for the session.

So, in the code of videos.jsp, I can implement a logic, something like if (session.getAttribute("uname")==null) request.sendRedirect("login.jsp") (means if the uname attribute in the session is not set, I should redirect the user to the login.jsp page)

Now whenever the user clicks on Logout button, he should be redirected to login page again using sendRedirect("login.jsp").

All this while, I need to keep in mind that the browser caches web pages, so if I press the back button, the videos.jsp page might still be visible, so I need to clear the meta tags (these details will be discussed in detail during coding).

In logout.java, Ihave used session. invalidate(),the basic function of this code is that: All objects bound to the session are removed.

If I click on back button, I am able to see the welcome.jsp page, even though I am not logged in, the reason is that the browser is caching the pages, caching is beneficial in one sense that it helps to load the pages faster, but over here it is not beneficial.


So, for handling this issue, I will use the "Cache Control" HTTP header, cache-control HTTP header field holds directives (instructions)- in both requests and reponses- that control caching in browsers and shared caches.


Here, I am using the policy as "no cache, no store, must revalidate"  in welcome.jsp and videos.jsp pages

Maven project and archetypes: TODO (This is where I last left)
